- [Мотиватор](#мотиватор)
- [Полезные ссылки](#полезные-ссылки)
- [База](#база)
  - [Форматный вывод](#форматный-вывод)
  - [Переменные](#переменные)
    - [Shadowing (*замещение, перекрытие - хз, как это лучше назвать*)](#shadowing-замещение-перекрытие---хз-как-это-лучше-назвать)
  - [Типы данных](#типы-данных)
    - [Скалярные типы](#скалярные-типы)
    - [Составные типы](#составные-типы)
      - [Кортеж (tuple)](#кортеж-tuple)
      - [Массив (array)](#массив-array)
  - [Функции](#функции)
    - [Statements and expressions](#statements-and-expressions)
  - [Управление исполнением (`if`, `for` и пр.)](#управление-исполнением-if-for-и-пр)
    - [`if`](#if)
    - [Циклы](#циклы)
      - [`loop`](#loop)
      - [`while`](#while)
      - [`for`](#for)
- [Владение (ownership)](#владение-ownership)
  - [Владение и функции](#владение-и-функции)
  - [Ссылки (references) и заимствование (borrowing)](#ссылки-references-и-заимствование-borrowing)
  - [Slices](#slices)
- [Структуры данных](#структуры-данных)
  - [Методы](#методы)
- [`enum` и `match`](#enum-и-match)
  - [`enum Option<T>`](#enum-optiont)
  - [Конструкция `match`](#конструкция-match)
  - [Циклы и ветвления с матчингом (`if let`, `while let`)](#циклы-и-ветвления-с-матчингом-if-let-while-let)
- [Коллекции](#коллекции)
  - [Векторы](#векторы)
  - [Итераторы и декларативные методы](#итераторы-и-декларативные-методы)
  - [Ещё раз о строках](#ещё-раз-о-строках)
  - [Мапы](#мапы)
- [Структура проектов](#структура-проектов)
  - [Контейнеры](#контейнеры)
  - [Пакеты](#пакеты)
  - [Модули](#модули)
    - [Главные правила модулей](#главные-правила-модулей)
    - [Навигация по модулям](#навигация-по-модулям)
      - [Настройки приватности](#настройки-приватности)
      - [`use`](#use)
    - [Разделение на файлы](#разделение-на-файлы)
      - [Комплексный пример сразу с исполняемым и библиотечным корневыми модулями](#комплексный-пример-сразу-с-исполняемым-и-библиотечным-корневыми-модулями)
- [Ошибки](#ошибки)
  - [`panic`](#panic)
  - [`Result`](#result)
    - [Проброс ошибок и оператор `?`](#проброс-ошибок-и-оператор-)
  - [Паниковать или нет?](#паниковать-или-нет)
- [Generics](#generics)


# Мотиватор
```
 __________________________
< Hello fellow Rustaceans! >
 --------------------------
        \
         \
            _~^~^~_
        \) /  o o  \ (/
          '_   -   _'
          / '-----' \
```

# Полезные ссылки
- [Книжка от создателей](https://doc.rust-lang.org/book/#the-rust-programming-language)
- [Репозиторий с упражнениями](https://github.com/rust-lang/rustlings/)
  - *На самом деле прямо в упражнениях идут ссылки на эту же книжку, так что просто её читать смысла не вижу*
- [Общий список операторов](https://doc.rust-lang.org/book/appendix-02-operators.html)

# База
## Форматный вывод
Несколько похоже на сишный `printf`, но в разы удобнее и сдополнительными приколюхами:
```rs
// In general, the `{}` will be automatically replaced with any
// arguments. These will be stringified.
println!("{} days", 31);

// Positional arguments can be used. Specifying an integer inside `{}`
// determines which additional argument will be replaced. Arguments start
// at 0 immediately after the format string.
println!("{0}, this is {1}. {1}, this is {0}", "Alice", "Bob");

// As can named arguments.
println!("{subject} {verb} {object}",
        object="the lazy dog",
        subject="the quick brown fox",
        verb="jumps over");

// Different formatting can be invoked by specifying the format character
// after a `:`.
println!("Base 10:               {}",   69420); // 69420
println!("Base 2 (binary):       {:b}", 69420); // 10000111100101100
println!("Base 8 (octal):        {:o}", 69420); // 207454
println!("Base 16 (hexadecimal): {:x}", 69420); // 10f2c

// You can right-justify text with a specified width. This will
// output "    1". (Four white spaces and a "1", for a total width of 5.)
println!("{number:>5}", number=1);

// You can pad numbers with extra zeroes,
println!("{number:0>5}", number=1); // 00001
// and left-adjust by flipping the sign. This will output "10000".
println!("{number:0<5}", number=1); // 10000

// You can use named arguments in the format specifier by appending a `$`.
println!("{number:0>width$}", number=1, width=5);

// For Rust 1.58 and above, you can directly capture the argument from a
// surrounding variable. Just like the above, this will output
// "    1", 4 white spaces and a "1".
let number: f64 = 1.0;
let width: usize = 5;
println!("{number:>width$}");
```

Все варианты обращения к аргументам форматного вывода можно смешивать (разве что именованные должны быть после позиционных), хотя весьма нежелательно

Простой форматный вывод `{}` реализуется через `fmt::Display`, который по умолчанию у пользовательских типах не реализуется

Вызов `{:?}` вызывает `fmt::Debug` (пока что мне мало о чём говорит запись через двоеточие. И даже не очень понятно, что это за штуки с большой буквы - методы, функции или что-то подобно)

## Переменные
Объявляются ключевым словом `let var;`

Базово иммутабельны. Мы можем лишь единожды присвоить значение либо в момент объявления, либо позже (но обязательно до первого использования значения)

Для создания мутабельной переменной надо использовать `let mut mutable_var;`

Также мы можем объявить константы в любой области видимости (обычные переменные вне функции объявить нельзя), написав `const CONSTANT_VAR: type = value;` (*про типы речь пойдёт дальше*)
- Им нельзя присвоить результат функции, но можно нескольких операций (`60 * 60 * 24`, чтобы задать секунды в сутках и т.п.)

### Shadowing (*замещение, перекрытие - хз, как это лучше назвать*)
Особый механизм, позволяющий замещать значение **ИММУТАБЕЛЬНОЙ** переменной (**не константы**) в определённой области видимости. Заключается в том, что мы повторно объявляем переменную с тем же именем, у которой может быть другое значение и даже тип. Новое значение будет использоваться до конца области видимости, в которой она объявлена

```rs
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}
```
Вывод:
```
The value of x in the inner scope is: 12
The value of x is: 6
```

Кроме примера выше может быть удобно в случаях, когда мы хотим использовать значение единожды, а потом работать с его производной другого типа, но не хотим плодить много разных имён
```rs
let response = "4";
let response: u32 = response.parse().expect("Not a number!");
```

## Типы данных
Rust - язык со статической типизацией (*которая, впрочем, в некоторых отношениях достаточно податливая благодаря замещению*), однако нам часто нет нужды объявлять тип переменной, так как компилятор может предположить его по присваиваемым значениям.

Однако в некоторых случаях тип необходимо указать явно, так как компилятору будет недостаточно информации (*пример с парсингом выше. Без указания типа компилятор вообще не будет знать, что ему парсить*)

Типы данных делятся на скалярные и составные

### Скалярные типы
Скалярные типы предназначены для хранения одного значения:
- Целочисленные типы
  - В основном всё банально: имя типа составляется из буквы `i`/`u` и количества бит `8`/`16`/`32`/`64`/`128`
  - Особые типы: `isize`/`usize` - могут иметь разный размер в зависимости от архитектуры системы, исполняющей код. (в основном `32` либо `64` бита)
  - По умолчанию - `i32`
  - Отдельно объясняют особенности переполнения типов:
    - В дебаг-режиме при переполнении прога будет падать при помощи `panic!`
    - В релизе будет происходить классическое переполнение
    - Чтобы чётко быть уверенным в том, что всё работает корректно, рекомендуют использовать защищённые методы-обёртки для математических операций, которые обрезать результат в дебаге (`wrapping_*`), возвращать `None` при переполнении (`checked_*`), говорить о переполнении булевой переменной (`overflowing_*`), ограничивать переполнение границами типа (`saturating_*`)
- Типы с плавающей точкой: `f32` / `f64`. По умолчанию - `f64`
- Логический тип. `bool`: значения `true`/`false` - ничего интересного
- Символьный тип. `char`. Хранит юникод-символ => размер 4 байта

Большинство операций над этими типами не отличаются от операций в других языках. Особенно похоже на плюсы

### Составные типы
Составные типы позволяют хранить в себе множество значений. В Rust есть 2 примтивных составных типа (*цитата из книжки. Слово "примитивный" тут несколько загадочно звучит, скорее всего оно носит лишь декоративный смысл*)

#### Кортеж (tuple)
Набор данных **произвольных типов фиксированной длины**

Тип описывается `(type1, type2, ...)`. Также в некоторых случаях компилятор может сам определить тип

Получить доступ к элементам кортежа можно двумя способами:
- Обратиться по индексу через точку: `tuple.index`
- Провести деструкцию скобками: `(elem1, elem2, ...) = tuple` (**количество элементов в деструкции должно быть равно размеру кортежа**)

Пустой кортеж `()` называется `unit` и обозначает не только пустой кортеж, но и пустой возвращаемый тип

#### Массив (array)
Набор данных **одного типа фиксированной длины**

Массивы располагают данные на стэке (*а кортежи выходит на куче? Ладно, это должны рассказать позже*)

Декларация типа выглядит так: `[type; length]`

При присвоении значений массиву вместо перечисления элементов в квадратных скобках через запятую можно также использовать конструкцию с точкой с запятой `[value; length]`

Также поддерживает обращение по индексам (`array[index]`) и деструкцию (`[elem1, elem2, ...] = array`)

## Функции
Базовый вид:
```rs
fn function_name(arg1: type, mut arg2: type, ...) {
  // Function body
}
```
- Указывать типы аргументов **ОБЯЗАТЕЛЬНО**
- Можно определять функцию как до, так и после места её вызова. Главное, чтобы была в той же области видимости

Куда более интересными будут функции, возвращающие значения

### Statements and expressions
*Переведу на русский это как "заявления" и "выражения"*

**Ключевая для Rust концепция**

Statement - команды, производящие определённые действия, но не возвращающие значений
- Её значение не может быть присвоено переменной
- Заканчивается на точку с запятой
- *Пример:* `let x = 5;`

Expression - команды, возвращающие определённое значение
- В конце не должно быть точки с запятой
- **Фигурные скобки - тоже выражение** (*если, конечно, после них не поставить `;`*)
- Возвращаемое выражением значение определяется строкой без `;`, которая **должна быть в конце**
  - Если в конце нет выражения, то будет возвращаться `()`
  - Конкретно для функции мы можем возвращать значение раньше конца при помощи Statement `return <expression>;`

Звучит, пожалуй, несколько запутанно, поэтому вот ряд примеров:
```rs
// Функция, возвращающая 5
fn five() -> i32 {
  5 // Expression (да-да. Константы - тоже выражение)
}

fn five() -> i32 {
    5 // Ошибка - требуется точка с запятой
    print!("test");
} // Ошибка - возвращается () вместо i32

fn five() -> i32 {
    return 5; // Statement, говорящий, что нужно вернуть Expression {5}
    print!("test");
}

fn five(a: i32) -> i32 {
    if a % 2 == 0 {
        return 5;
    }
    print!("test");
} // Ошибка - возвращаемое значение может быть () вместо i32 (жесть тут умный компилятор)

// А теперь самые ядрёные примеры
fn sale_price(price: i32) -> i32 {
    if is_even(price) {
        price - 10
    } else {
        price - 3
    }
} // Корректно отработает, так как if - тоже выражение, возвращающий тот же тип, что и его условные выражение

fn sale_price(price: i32) -> i32 {
    if is_even(price) {
        price - 10
    } else {
        price - 3
    }
    println!("a");
} // Ошибка - возвращаемое значение () вместо i32

fn sale_price(price: i32) -> i32 {
    println!("a");
    if is_even(price) {
        price - 10
    } else {
        price - 3
    }
} // OK

fn sale_price(price: i32) -> i32 {
    return if is_even(price) {
        price - 10
    } else {
        price - 3
    };
    println!("a");
} // OK

fn sale_price(price: i32) -> i32 {
    if is_even(price) {
        return price - 10;
    } else {
        return price - 3;
    }
    println!("a");
} // OK

// Ясное дело, в последних двух примерах строка не выведется
```
*Выглядит страшновато, согласен, но спасает ситуацию то, что мы можем по классике использовать `return` - и не задумываться о таких тонкостях*

*Ну и да, если возвращается не `()`, то возвращаемый тип обязательно надо указывать*

## Управление исполнением (`if`, `for` и пр.)
### `if`
По большей части всё тривиально, интересный момент лишь в том, что условие (condition), определяющее ветку ифа - это тоже выражение (expression). Таким образом, обернув его в фигурные скобки, мы можем проводить там дополнительные операции:
```rs
fn bigger(a: i32, b: i32) -> i32 {
    // Если condition занимает одну строку, фигурные скобки можно опустить
    if a > b { 
        a
    } else {
        b
    }
}

// Эквивалентная функция
fn bigger(a: i32, b: i32) -> i32 {
    if {
        let diff = a - b;
        diff > 0
    } {
        a
    } else {
        b
    } // Скобки вокруг ветвей ифа опускать НЕЛЬЗЯ
}
```

Как уже отмечалось в примерах для функций, if expression имеет тот же возвращаемый тип, что и его ветки. Из этого следует, что мы можем использовать его в каком-нибудь statement:
```rs
// Ещё один эквивалент функциям выше
let maxNumber = if a > b {a} else {b}; // Приятнее классического тернарного оператора, не правда ли?
```

*Ну и `else if` тут тоже, само собой, есть*

### Циклы
#### `loop`
*Встроенный `while true`*

Также можно использовать `break` и `continue`, но с первым есть ряд фишек:
- `loop` - тоже expression. Его тип определяется expression, записанным после `break`:
```rs
let mut counter = 0;
let result = loop {
    counter += 1;
    if counter == 10 {
        break counter * 2;
    }
};
```
- Если прописать `'label: loop {}`, то вызов `break 'label;` прервёт именно этот цикл, даже если он не самый вложенный

#### `while`
Тут ничего особо интересного нет. Конструкция `break` обладает теми же доп. фишками
```rs
let mut counter = 0;

let result = 'test: while counter < 10 {
    if counter == 5 {
        break counter;
    }
    print!("{counter}");
    counter += 1;
};
```

#### `for`
В Rust используется конструкция `for-in` (похоже на Питон)

**ВСЕГДА ВОЗВРАЩАЕТ `()`** (нельзя использовать `break expression;` - только простой `break`)

Может итерироваться по любым коллекциям. `Range` задаётся конструкцией `start..end` (все числа в интервале `[start, end)`)

---

Про `match` читай [тут](#конструкция-match)

# Владение (ownership)
Уникальная фишка Rust, позволяющая безопасно работать с памятью, не используя сборщик мусора

*Для начала объясняется самая база про стэк и кучу, которая, спасибо Иртегову, мне ясна достаточно хорошо*

Основы владения:
- У каждого значения есть свой **владелец**
- Владелец может быть **только один в один момент времени**
- Когда владелец покидает область видимости, связанные с ним значения отбрасываются

В целом, эти правила описывают классическую ситуацию использования стэка. Ключевое отличие, что они также применяются и для участков памяти, расположенных на куче, что позволяет нам не тратить время на сборку мусора и, в то же время, не следить вручную за всей работой с памятью, однако может привести к неожиданным последствиям в некоторых случаях

Если данные по определённому указателю располагаются на куче и при этом для них реализована черта (trait - о них будет рассказано далее) `Drop`, то память по этому указателю будет очищена после выхода из области видимости указателя. Проблема возникнет в случае, когда у нас будет несколько типов данных с указателем на одну и ту же память:
```rs
{
    let mut s1 = String::from("some string");
    let mut s2 = s;
    // mut здесь дэ-факто не используется, но им я хотел подчеркнуть, что тип String, в отличие от строчного литерала str, может быть мутабельным в плане расширения строки и прочего
}
```
В этом примере в `s2` из `s1` скопируются значения полей типа `String`: указатель на область в памяти, где хранится строка, длина и макс. размер, то есть указатель у них один и тот же, из-за чего при выходе из области видимости `s1` и `s2` память под строку могла бы быть очищена дважды. 

Решается эта проблема тем, что `s1`, после копирования полей типа в `s2`, помечается невалидным - он не может далее использоваться и не будет проведена попытка очистки после выхода из области видимости

Таким образом, при приравнивании типов с чертой `Drop` происходит не поверхностное копирование (`shallow_copy`), а перемещение (`move`).

Чтобы всё же пользоваться обоими переменными, мы должны при присваивании вызывать метод `.clone()`, который скопирует содержимое памяти в новую область на куче (*`deep_copy`, хотя учитывая примитивность типа здесь этот термин не до конца применим*) (**более затратная операция, ясное дело**)

Поведение для примитивных типов отличается: их значения копируются быстро и не содержат сложной структуры, поэтому для строк
```rs
let x = 5;
let y = x;
```
в обеих будет значение 5 и обе продолжат быть валидными до конца области видимости (можно сказать, что тут неявно вызывается `.clone()`)

Кроме совсем примитивных типов, это относится к кортежам из примитивных типов и всем типам, реализующим черту `Copy` (*о том, как её реализовать, речь пойдёт сильно позже*)

## Владение и функции
При передаче аргументов в функции реализуется паттерн `move` для сложного типа и копирование для простого. То есть переданная переменна типа, реализующего черту `Drop`, после вызова функции перестанет быть валидной.

```rs
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it's okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
```

Владение возвращаемыми из функции данными, что логично, передаётся туда, где функция была вызвана

## Ссылки (references) и заимствование (borrowing)
Как следует из сказанного выше, после передача аргумента сложного типа в функцию, мы не сможем им пользоваться, так как владение на его значение было передано в другое место, где позже это значение было очищено.

Продолжить использование данных можно, передав аргумент обратно вместе с результатом, упаковав всё в кортеж, но это весьма неудобно, поэтому предлагается использовать ссылки.

**Ссылка** `&` позволяет нам назначить новую переменную со сложным типом без передачи владения:
```rs
let s = String::from("str");
let rs = &s;
println!(s); // OK
```
и
```rs
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    // Мы без проблем можем использовать s1 и после функции
    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

**Заимствованием** называется, собственно, доступ к объекту по ссылке (*мы временно берём владение на него, но потом возвращаем обратно*)

Использование ссылки **не делает объект мутабельным**. Этот код не скомпилируется:
```rs
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
```

Для аргумента функции нужно явно указать, что это мутабельная ссылка + исходный объект также должен быть мутабельным:
```rs
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
Напротив, мы можем создавать иммутабельные (обычные) ссылки на мутабельный объект

Если в области использования есть мутабельная ссылка, то она **должна быть единственной ссылкой на объект**
- **ВАЖНО:** речь именно об области использования. Область использования кончается там, где ссылка **была вызвана в последний раз**

Работает:
```rs
let mut s = String::from("aaa");
let rs = &mut s;
println!("{rs}");
{
    let rs2 = &mut s;

    println!("{rs2}");
}
```
Работает:
```rs
let mut s = String::from("aaa");
let rs = &mut s;
println!("{rs}");
let rs2 = &mut s;
println!("{rs2}");
```
НЕ РАБОТАЕТ:
```rs
let rs = &mut s;
let rs2 = &mut s;
println!("{rs2}");
println!("{rs}");
```
Иммутабельных ссылок на объект может быть много (**мутабельную вместе с ними, пусть даже одну, использовать нельзя**)

Правила могут казаться через строгими и порой неудобными, однако они позволяют ещё на этапе компиляции избежать многих возможностей создания data races (aka race condition)

Теоретически, ссылки могли бы быть висячими, если, например, мы бы возвращали её из функции на созданный в этой же функции объект (возвращение ссылки не передаёт владение, поэтому объект будет очищен в конце функции), однако компилятор следит и за этой ситуацией. Следующий код не запустится:
```rs
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String { // dangle returns a reference to a String

    let s = String::from("hello"); // s is a new String

    &s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
```

Очень-очень вероятно, что получение из функции ссылки - не то, чего мы хотим, поэтому стоит просто передавать владение:
```rs
fn no_dangle() -> String {
    let s = String::from("hello");
    s
}
```

Таким образом, нам гарантируется, что используемые референсы всегда валидны

## Slices
Среза в Rust являются особо структурой данных, а не просто коллекцией того же типа

Срез представляет собой структуру из указателя на данные и длины и создаётся путём обращения по указателю к переменной с изначальным типом и указания в квадратных скобках границ среза:
```rs
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]); // Ассёрт пройдёт корректно
```

Особенно часто используются срезы для строковых литералов (а на самом деле все строковые литералы представляют собой срез строки, хранящейся в бинарнике).

Преимуществом срезов является то, что они являются ссылками => гарантируется валидность данных, на которые указывает срез (*ну и все прочие моменты держим в голове вроде того, что мутабльный срез может быть лишь в одиночку*).

Этот код не вызовет ошибки, хотя после `.clear()` может работать некорректно:
```rs
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to ""

    // word still has the value 5 here, but there's no more string that
    // we could meaningfully use the value 5 with. word is now totally invalid!
}

fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
```

В свою очередь здесь компиляция упадёт на строке с очисткой, так как срез используется после неё (`.clear()` ввиду влияния на данные, внутри также пытается получить мутабельную ссылку):
```rs
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // error!

    println!("the first word is: {}", word);
}

fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

Дополнительно можно передавать в функцию `s: &str`. Это позволит функции одинаково работать как со строковыми литералами, так и со строками, так и с их срезами
```rs
fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or whole
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
```

*Возможно не до конца верная, но валидная, на мой взгляд, интерпретация:* таким образом, **срез** - ссылка на коллекцию или её часть

# Структуры данных
Объявление структур и их базовое использование очень банальны:
```rs
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}
```
Мутабельной может быть только вся структура целиком:
```rs
fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}
```

Если какие-то поля структуры у нас уже есть как отдельные переменные, мы можем использовать сокращённую запись:
```rs
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }

    // Вместо вот этого
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
```

Для копирования структуры можно использовать `..`:
```rs
fn main() {

    let user2 = User {
        email: String::from("another@example.com"),
        ..user1 // ВАЖНО: тут ставить запятую уже нельзя. Также надо указывать все изменённые значения выше этого типа "spread"-оператора
    };

    // Вместо:
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}
```

Для реализующих `Drop` типов **произойдёт передача владения**. По этой причине такие поля у `user1` перестанут быть доступны

Существуют также кортежи-структуры, которы позволяют к определённому имени привязать набор значений определённого типа, не давая им имена:
```rs
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
```
Несмотря на одинаковые поля, `Color` и `Point` - разные типы - одни нельзя заменить другими, однако и те, и другие поддерживают деструкцию и обращение по индексам

Можно создать структуру без полей, смысл которых будет раскрыт далее (*но если в общем, то они могут говорить о каком-то свойстве или чему-то сопоставляться*):
```rs
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
```

## Методы
*Обычные функции используются с объектами довольно тривиально и по всем описанным ранее правилам, так что сразу перейду к методам*

Создаются методы по следующему синтаксису:
```rs
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```

Первым аргументом у методов всегда должен быть параметр типа `Self` (вместо `self: Self` можно писать просто `self`), причём чаще всего это будет `&self` либо `&mut self`, так как правила владения тут те же => после вызова метода с аргументом просто `self`, вызывающий объект перестанет быть валидным (используется, когда мы что-то возвращаем и явно хотим закрыть доступ к исходному объекту)

Мы также можем задать статические методы (*зовутся здесь просто "ассоциированные со структурой методы без `self`"*):
```rs
impl Rectangle {
    fn square(size: u32) -> Self {
        Self {
            width: size,
            height: size,
        }
    }
}
```
Вызываться такой будет как `from()` для строк: `Rectangle::square(...)`

# `enum` и `match`
Базовое создание `enum`ов и их использование весьма тривиально:
```rs
enum IpAddrKind {
    V4,
    V6,
}

// ...

let four = IpAddrKind::V4;
let six = IpAddrKind::V6;

// ...

fn route(ip_kind: IpAddrKind) {}
```

Больше интереса представляет задание полей для значений энума: они могут отличаться от значения к значению, что очень редко встречается в других языках:
```rs
    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
        Dns {
            name: String
        }
    } 
    //! дэ-факто здесь будут автоматически определяться методы конструкторы вида 
    //! fn ENUM_NAME(arg1: type1, ...) -> Self {...}

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
```
Достаточно часто используется такой паттерн. Задаётся `enum` с набором возможных значений, каждое из которых имеет одно поле со структурой данных этого значения типа:
```rs
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```

Для `enum`ов можно также определить методы внутри `impl {...}`

## `enum Option<T>`
Особый `enum`, который надо использовать вместо концепции `null`. Определяется так:
```rs
enum Option<T> {
    None,
    Some(T),
}
```

Ввиду частого использования, части этого энума экспортируются и сами по себе, поэтому при инициализации можно писать просто `None` или `Some(type)`

*Ещё здесь используются generic'и, но о них речь пойдёт позже*

## Конструкция `match`
Матчинг является своего рода улучшением `switch-case` оператора с добавлением фишек паттерн-матчинга. Общий вид конструкции такой
```rs
match <matchableExpression> {
    <matchExpressionValue1> => <resultExpression1>,
    <matchExpressionValue2> => <resultExpression2>,
    <matchExpressionValue3> => { // Long expression
        <cmd1>;
        <cmd2>;
        <returnExpression>
    }, // Тут скобка опциональна
    <matchExpressionValue4> => <resultExpression4>,
    other => <resultExpressionForOtherMatches>, // other - НЕ КЛЮЧЕВОЕ СЛОВО, а просто переменная, которой мы присвоили все остальные значения, не описанные в ветках выше
    other2 if <conditionExpression> => <resultExpressionForOtherMatches>, // И так тоже можно! Очень удобно писать вместо множества взаимоисключающих ифов
    _ => <resultExpressionForOtherMatches>, // вариант для всех остальных значений, когда само значение нас не интересует
}
```
- `match` также является expression, а значит его результат можно возвращать из функции или присвоить переменной + его ветки - expression'ы того же типа
- ветки матча должны покрывать всё множество возможных значений

Реальный пример для автомата по сортировке монет:
```rs
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

Очень важная фишка матчинга - извлечение параметров: если одно из значений энума имеет параметры, то при матчинге мы можем дать им имена, к которым привяжутся в этой ветке значения (условный матчинг с этим работает также хорошо):
```rs
#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState), // Теперь монеты в 25 центов уникальны для каждого штата
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
```

## Циклы и ветвления с матчингом (`if let`, `while let`)
Эта конструкция будет удобнее матчинга в случае, когда мы хотим делать что-то лишь с одной веткой и не хотим писать лишних слов для покрытия остальных:
```rs
let result = Some(2);
match result {
    Some(value) => println!("{value}"),
    _ => (),
}
// Эквивалентная запись:
if let Some(value) = result {
    println!("{value}");
}

// else также поддерживается
let result = Some(2);
match result {
    Some(value) => println!("{value}"),
    _ => println!("Here's nothing"),
}
// Эквивалентная запись:
if let Some(value) = result {
    println!("{value}");
} else {
    println!("Here's nothing");
}
```

**НЕ ЗАБЫВАЕМ О СПЕЦИФИКИ ВЛАДЕНИЯ!** Код ниже выдаст ошибку:
```rs
if let Some(p) = y { // Здесь мы передали владение на y конструкции if let, которая его распакует
    println!("Co-ordinates are {},{} ", p.x, p.y)
} else {
    panic!("no match!")
}
y; // Поэтому здесь ссылка будет уже не валидной
```
К счастью, решается проблема просто:
```rs
if let Some(p) = &y { // Владение не передаётся
    println!("Co-ordinates are {},{} ", p.x, p.y)
} else {
    panic!("no match!")
}
y; // OK
```

*Почти аналогично работает конструкция `while let`*

# Коллекции
[Документация по всем стандартным коллекциям](https://doc.rust-lang.org/std/collections/index.html)

Все коллекции хранятся на куче со всеми вытекающими последствиями

## Векторы 
[Документация по векторам](https://doc.rust-lang.org/std/vec/struct.Vec.html)

```rs
// Объявляется либо статическим методом
let v: Vec<i32> = Vec::new(); // В таком случае нужно обязательно указывать тип

// Либо через макрос
let v = vec![1, 2, 3];
```

Если после объявления вектора для него используются лишь операции с одним типом данных, компилятор также сможет автоматически определить тип:
```rs
let mut v = Vec::new(); // Будет тип Vec<i32>

v.push(1);
v.push(2);
```

Обращение к индексам может быть двумя способами:
```rs
    let v = vec![1, 2, 3, 4, 5];

    let third: &i32 = &v[2];
    println!("The third element is {third}");

    let third: Option<&i32> = v.get(2);
    match third {
        Some(third) => println!("The third element is {third}"),
        None => println!("There is no third element."),
    }
```
Насчёт ссылок в этом примере: дэ-факто они не нужны, так как `i32` - простой тип, реализующий черту `Copy`, поэтому для него указания `&` не играет особой роли:
```rs
let v = vec![1, 2, 3, 4, 5];

let third_ref = &v[2];
let third = v[2];

println!("The third element is {third_ref}");
println!("The third element is {third}");
println!("The third element is {}", v[2]); 
// Мы спокойно можем обращаться к самому элементу, так как в third его значение было просто скопировано
```
Однако для сложных типов с чертой `Drop` в силу вступают все правила владения и одалживания, поэтому присвоение элемента без `&` приведёт к разрушению вектора и блокируется компилятором
```rs
let mut str_vec: Vec<String> = Vec::new();
str_vec.push(String::from("aaa"));
str_vec.push(String::from("bbb"));

let second_ref = &str_vec[1];
let second = str_vec[1]; // Ошибка
println!("The third element is {second_ref}");
println!("The third element is {second}");
println!("The third element is {}", str_vec[1]);
```

Все правила насчёт мутабельных референсов также актуальны:
```rs
let second_ref = &str_vec[1];
let second = &mut str_vec[1]; // Ошибка
second.push('c');
println!("The third element is {second_ref}");
println!("The third element is {}", str_vec[1]);
```
```rs
let second = &mut str_vec[1];
second.push('c');
let second_ref = &str_vec[1];
println!("The third element is {second_ref}");
println!("The third element is {}", str_vec[1]);
// Всё окей, так как область использования second кончается до начала области использования second_ref
```
Следует учитывать сайд-эффекты внутри коллекции, которые могут также приводить к изменению, например, расположения данных, а значит требуют мутабельных референсов:
```rs
let second_ref = &str_vec[1];
str_vec.push(String::from("ccc")); // Ошибка, так как в ходе push данные могли бы быть перемещены в памяти, а значит second_ref мог стать не авлидным
println!("The third element is {second_ref}");
println!("The third element is {}", str_vec[1]);
```

По векторам можно итерироваться через `for-in`, причём брать элементы как иммутабельными, так и мутабельными референсами:

```rs
for i in v { // Можно писать и так, но ввиду механики владения далее пользоваться вектором будет невозможно (удивительно, что в отличие от)
    println!("{i}");
}

// По этой причине итерация почти всегда будет по референсам

for str_ in &str_vec {
    str_.push('0');
    println!("{str_}");
}

for str_ in &mut str_vec {
    str_.push('0');
    println!("{str_}");
}

// Из-за использования ссылок при итерировании, параллельно добавлять, удалять элементы или вызывать любые другие операции, использующие мутабельные референсы на вектор, невозможно
```

В некоторых случаях (*пока что точно не уверен, но вроде бы для элементарных типов*) для использования операций над значением по мутабельному референсу, необходим дереференс:
```rs
for element in v.iter_mut() { // v.iter_mut() будет эквивалентно &mut v
    *element *= 2;
}
```

## Итераторы и декларативные методы
*Не буду здесь особо много писать и уж тем более перечислять все методы, просто отмечу основные моменты*

Получив итератор на коолекцию (`.iter()` либо `.iter_mut()`, хотя второй тут очеьн сомнителен), мы можем пользоваться методами вроде `.map()`, `.reduce()`, `.filter()` и многими другими:
```rs
fn vec_map(v: &Vec<i32>) -> Vec<i32> {
    v.iter().map(|element| {
        element * 2
    }).collect()
}

// Либо

fn x2(elem: &i32) -> i32 {
    elem * 2
}

fn vec_map(v: &Vec<i32>) -> Vec<i32> {
    v.iter().map(x2).collect()
}
// В этой версии становится чуть яснее, что лямбда-функция не принимает владение (что и логично достаточно)
```
- `.collect()` преобразует итератор обратно в коллекцию, её тип может быть указан перед скобками в `<>` либо определиться в зависимости от других частей

Заодно здесь видно базовый синтаксис лямбда-выражений: `|args...| {expression}`, но подробнее о них, думаю, речь пойдёт позже. (особенно вопросы сейчас возникают, а надо ли тут обращаться по референсам или нет)

## Ещё раз о строках
Как уже говорилось, строками в Rust являются стрезы `str` (причём чате всего это `&str`, указывающие на нужную область бинарного файла) и особый тип стандартной библиотеки `String`.

`String` очень похожа на `Vec<T>`, но накладывает кое-какие дополнительные ограничения и добавляет методы для работы со строками.

У любого объекта с чертой `Display` реализуется метод `.to_string()`, возвращающий строку

Добавление элементов в строку реализуется многими способами:
```rs
let my_str = String::from("aaa");
my_str.push('b'); // my_str = "aaab"
my_str.push_str("ccc"); // my_str = "aaabccc"
let s2 = String::from(" ddd");
my_str = my_str + &s2; // my_str = "aaabccc ddd"
// Важно, что в последней строке мы передаём владение для первого аргумента и не передаём для второго, так как им мы ещё возможно захотим воспользоваться
```

Во многих функциях используется аргумент типа `&str`, однако мы спокойно можем передавать туда переменные типа `&String`. Вызвано это тем, что при передаче значения в переменную, может быть проведён дереференс с принуждением, вызывающий вместо `&s2` `&s2[..]` (*подробнее про смысл этого действия и других фишек, связанных со срезами, будет сильно позже*)

Сложной комбинации значений в строку удобно использовать макрос `format!()`, имеющий аналогичный `println!()` синтаксис:
```rs
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{s1}-{s2}-{s3}");
```

Доступ к строкам по индексу запрещён, так как ввиду родства с вектором, ожидается, что будут возвращаться значения `u8`, которые в то же время должны быть символами, однако для `UTF-8` это очень часто вообще не так. Более того, срез допустим только по границам байтов символов, то есть:
```rs
let s = "Привет"; // Занимает 12 байт (и длина строки будет такая же)
let slice = &s[0..4]; // OK
let slice2 = &s[0..3]; // Ошибка, так как из второго символа взят только первый байт
```

*Не очень удобно, правда?* Зато безопасно и однозначно. А самый оптимальный вариант работы с элементами строки - указать напрямую, хотим ли мы символы или байты, а дальше работать с ними. Это позволяют сделать методы `.chars()` и `.bytes()`, возвращающие итераторы для работы в соответствующем режиме

## Мапы
Основные моменты достаточно тривиальны:
- `HashMap::new()` - констурктор
- `insert(key: K, value: V)` - добавить элемент (**с передачей владения**)
  - Хотя на самом деле можно сделать мапы и из ссылок, но тогда надо будет с большой осторожностью следить за сроком жизни значений мапы
- `get(key) -> Option<&V>` - получить значение
- Тим мапы можно не указывать явно, если в неё добавляется хотя бы одна пара

Из примечательного:
- Для использования надо прописать `use`: `use std::collections::HashMap;`
- При итерировании через `for-in` будем получать кортежи `(key, value)`
- Базовая хэш-функция - sip-hash - устойчива к DoS-атакам, однако если вдруг возникнет потребность, можно провести замену на иную хэш-функцию (объект, реализующий черту `BuildHasher`)

По ключу может быть лишь одно значение, поэтому нам надо решить, как именно поступать в разных ситуациях при добавлении значения:
- `.insert()` затирает прошлое значение, если оно было
- Метод `.entry(key)` вернём особый энум `Entry`, для которого определён ряд методов, позволяющий работать со значениями из мапы: 
  - `.or_insert(value)` - вставит по ключу значение в случае, если сейчас там ничего нет
  - Почти все методы возвращают мутабельный указатель на значение в мапе (которое уже (возможно) было изменено), что позволяюет нам дополнительно модифицировать значение
    - В некоторых случаях более красивый вариант - использовать метод `.and_modify()`, принимающий функцию, которая принимает мутабельный указатель на значение в том случае, если оно уже было (в сущности, эти 2 варианта друг другу не противоречат, так как используются немного по разному)
```rs
use std::collections::HashMap;

fn main() {
    // Прога, считающая количество вхождений каждого слова в текст

    let text = "hello world wonderful world";

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!("{:?}", map);
}

```

# Структура проектов
## Контейнеры
Crate (контейнер) - минимальная единица компиляции в Rust. Контейнер может содержать модули, которые могут быть определены тут же или в других файлах, скомпилированных вместе с контейнером.

- Исполняемые контейнеры предназначены для исполнения (*вот это поворот*) и содержат функцию `main`
- Контейнеры-библиотеки предоставляют использующим их различную функциональность для использования в других местах

## Пакеты
Package (пакет) - набор контейнеров. Обязательно содержит `Cargo.toml` файл, описывающий, как собрать контейнеры воедино. Может содержать сколько угодно исполняемый контейнеров, но максимум один библиотечный

Корневой контейнер - точка, с которой начинает сборка пакета или его части

Не все корневые контейнеры надо указывать в `Cargo.toml`:
- `src/main.rs` - путь по умолчанию для исполняемого контейнера
- `src/lib.rs` - путь по умолчанию для библиотечного контейнера с именем таким же, как у папки пакета (хотя в `Cargo.toml` это наверняка должно изменяться при желании)

## Модули
### Главные правила модулей
1. Модуль объявляется инструкцией `mod some_module;` - после этого компилятор будет искать код модуля в следующих местах
   1. В том же файле в области `mod some_module { ... }` (в этом случае вообще нет смысла разделять декларацию и определение)
   2. По путям `./some_module.rs` либо `./some_module/mod.rs` (путь относительно места декларации и/или использования)
2. Как только модуль определён, мы можем получить доступ к его объектам (при условии, что они публичны) по полному пути через `::`
3. Чтобы сделать объекты модуля публичными, надо при объявлении модуля указать `pub mod some_module { ... }` + для функций указывать `pub fn` - все остальные функции будут приватными и не смогут быть вызваны снаружи модуля
   - Подробнее про видимость объектов
4. `use path::to::Object` позволит писать в этом файле далее не весь путь, а только его окончание, то есть `Object`

Теперь рассмотрим в подробностях. Структура проекта, который является исполняемым контейнером `backyard`:
```
backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
```

Для использования в `main.rs` объекта `Asparagus` из подмодуля `vegetables` модуля `garden` мы пишем следующее:
```rs
use crate::garden::vegetables::Asparagus; // сокращение для Asparagus

pub mod garden; // Подключаем модуль garden, который будет найден в src/garden.rs

fn main() {
    let plant = Asparagus {};
    println!("I'm growing {:?}!", plant);
}
```
`src/garden.rs`:
```rs
pub mod vegetables; // Подключаем модуль vegetables, который будет найден по пути src/garden/vegetables.rs
```
`src/garden/vegetables.rs`:
```rs
#[derive(Debug)]
pub struct Asparagus {}
```

### Навигация по модулям
Пути до объектов в модулях, как и в файловых системах, делятся на 2 типа:
- Относительные - начинаются с имени модуля, доступного из текущего модуля
  - `self` позволяет обратиться к текущему модулю (*её существование несколько загадочно... Разве что для читабельности*)
  - `super` позволяет обратиться к родительскому модулю
- Абсолютные - начинаются с имени контейнера, а далее идёт путь до объекта, начиная с корневого модуля
  - Если мы обращаемся к тому же контейнеру, в котором работаем, то имя контейнера может быть заменено на ключевое слово `crete`, а за ним будет идти путь относительно `src/main.rs` либо `src/lib.rs` (*отсюда напрашивается вывод, что файлы сами по себе также являются модулям, но пока что нет в этом уверенности*)

Как уже писалось ранее, проект может содержать 2 или более корневых контейнера (но не более одного библиотечного). Рассмотрим ситуацию с одним исполняемым и одним библиотечным:
- Описывать дерево модулей надо в `src/lib.rs`
- Обращаться к коду в `src/main.rs` надо через `src/lib.rs` (**то есть использовать можно уже исключительно имя проекта, а не `crate`**)

#### Настройки приватности
По умолчанию все объекты в Rust создаются приватными и могут быть использованы только в своём модуле

Для открытия доступа к объекту из других модулей, необходимо прописать `pub` для **всех объектов** на пути к интересующему нас: на модули навешивается `pub`, чтобы мы могли обращаться к самому модулю; на функции и другие объекты (структуры, энумы и т.п.) внутри модулей, чтобы мы могли, собственно, их вызвать (*по сути, если рассматривать в данном случае модули и прочие объекты как сущности единой природы, это перестаёт быть странным, а если опираться на понимание модификаторов доступа из Java, то вопросов и вовсе возникнуть не должно*)

```rs
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
```
- Убирание любого из двух `pub` внутри модуля `front_of_house` приведёт к ошибке доступа
- Перед `mod front_of_house` писать `pub` для работы `eat_at_restaurant()` не нужно, так как эта функция и модуль находятся в одном модуле

Хотя правила и такие же, для структур и энумов есть некоторые нюансы.

Публичный доступ, при необходимости, надо прописывать не только у самой структуры, но и у его полей:
```rs
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    // Для impl pub не нужен
    impl Breakfast {
        // А для методов всё работает стандартно
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from("blueberries");
}
```

Если написать `pub enum`, то у него уже все значения сразу станут публичными

#### `use`
Импорт / линковка - `use path::to::object` - позволяет нам в текущей области видимости получить доступ к `object` без указания полного пути.
- **Именно в текущей области** - в потомках ссылка работать не будет (*но можно сделать ссылку на ссылку вместо полностью новой ссылки, что, впрочем, весьма сомнительно*)
- По общепринятым правилам для функций принято линковать содержащий их модуль, а для структур данных - их самих

Можно переименовать импортируемый символ, написав `use path::to::object as new_name`

Мы можем ре-экспортировать импортированный объект, добавив перед импортом `pub`. Может быть полезно для организации дерева вызовов, отличающегося от дерева модулей

Пример этих фич:
```rs
mod delicious_snacks {
    // TODO: Fix these use statements
    pub use self::fruits::PEAR as fruit;
    pub use veggies::CUCUMBER as veggie;

    mod fruits {
        pub const PEAR: &'static str = "Pear";
        pub const APPLE: &'static str = "Apple";
    }

    mod veggies {
        pub const CUCUMBER: &'static str = "Cucumber";
        pub const CARROT: &'static str = "Carrot";
    }
}

fn main() {
    println!(
        "favorite snacks: {} and {}",
        delicious_snacks::fruit,
        delicious_snacks::veggie
    );
}
```

Для сложных импортов поддерживаются 2 механизма:
- Вложенные пути: `path::to::{obj1, obj2, deep::obj3}` - импортирует `obj1`, `obj2` и `obj3`
  - `path::to::obj::{self, nested}` - ключевое слово `self` позволит импортировать сам `obj`
- Глоб: `path::to::*` - импортирует все публичные объекты из `path::to`

### Разделение на файлы
Высказанное ранее предположение, оказалось верным - файлы сами по себе тоже воспринимаются как модули.

Для контейнера мы должны построить дерево модулей. Делается это при помощи декларации `mod module_name;` или `pub mod module_name;`
- Для каждого модуля на проект должна быть одна декларация
- Встретив декларацию, компилятор будет искать модуль либо в том же файле (не наш случай), либо по одному из путей:
  - Имя файла - `module_name.rs` - расположен в папке с именем родительского модуля либо в `src`, если родитель - корневой модуль
  - Имя файла - `mod.rs` - расположен в подпапке `module_name` папки с именем родительского модуля либо в `src`, если родитель - корневой модуль (считается устаревшим стилем, так как будет много файлов с именем `mod.rs`, что не особо удобно)

---

#### Комплексный пример сразу с исполняемым и библиотечным корневыми модулями
```sh
src
├── hello_modules
│   ├── afternoon.rs
│   ├── evening.rs
│   └── morning.rs
├── hello_modules.rs
├── lib.rs
└── main.rs
```
`src/lib.rs` (корневой библиотечный модуль):
```rs
pub mod hello_modules;
```
`src/hello_modules.rs`:
```rs
pub mod morning;
pub mod afternoon;
pub mod evening;

pub fn print_info() {
  println!("This is module with different greetings");
}
```
`src/hello_modules/morning.rs`:
```rs
pub fn hello() {
  println!("Good morning!");
}
```
*В остальных двух файлах различие только в выводимой строке*

---

`src/main.rs` (корневой исполняемый модуль):
```rs
use hello_world_project::hello_modules;
use hello_modules::{
    morning::hello as good_morning,
    afternoon::hello as good_afternonn,
    evening::hello as good_evening,
};

fn main() {
    hello_modules::print_info();
    good_morning();
    good_afternonn();
    good_evening();
}
```

# Ошибки
Ошибки, как и во многих языках, бывают обязательные к обработке (`recoverable`) и смертельные (`unrecoverable`)

## `panic`
Вызывается макросом `panic!(message: &str)`, после чего исполнение прервётся и будет выведено сообщение об ошибке (**нормальное при том**).

Чтобы напечатать весь трейс ошибки, нужно перед запуском `cargo` задать переменную окружения `RUST_BACKTRACE`, отличную от нуля

По умолчанию, при панике происходит полная очистка занимаемых программой ресурсов (`unwinding`), что может быть весьма долго. Можно поменять поведение на простое прерывание без полной очистки, что сделает бинарник легче, а его работу быстрее. Для этого в `Cargo.toml` надо добавить `panic = 'abort'` к одному из профилей, чаще всего к релизному:
```toml
[profile.release]
panic = 'abort'
```

## `Result`
Этот энум может иметь хорошее и плохое состояние:
```rs
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```
Как нетрудно догадаться, `T` - тип возвращаемого при успехе значения, `E` - тип ошибки. Работать можно через любые конструкции для распаковки энумов

Кроме того, есть у энума `Result` дополнительные методы:
- `.unwrap_or_else(|error: E| -> T {...}) -> T` - возвращает успешное значение либо вызывает лямбда-функцию при ошибке, которая уже может либо вызвать панику, либо вернуть значение типа `T`

Вариант с матчами:
```rs
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => {
                panic!("Problem opening the file: {:?}", other_error);
            }
        },
    };
}
```

Вариант с `.unwrap_or_else()`:
```rs
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}
```

- В случае, когда при ошибке поведение заключается в панике, можно использовать эти методы:
- `.unwrap()` - распаковывает и возвращает успешное значение либо паникует в случае ошибки
- `.expect(message)` - распаковывает и возвращает успешное значение либо паникует в случае ошибки, выводя при этом кастомное сообщение

Можно применить функцию к хорошему значению, плохому значению или обоим, используя `.map(f)`, `.map_err(g)` или `.map_or_else(f, g)` соответственно. Пример:
```rs
enum ParsePosNonzeroError {
    Creation(CreationError),
    ParseInt(ParseIntError),
}

impl ParsePosNonzeroError {
    fn from_creation(err: CreationError) -> ParsePosNonzeroError {
        ParsePosNonzeroError::Creation(err)
    }
    fn from_parseint(err: ParseIntError) -> ParsePosNonzeroError {
        ParsePosNonzeroError::ParseInt(err)
    }
}

fn parse_pos_nonzero(s: &str) -> Result<PositiveNonzeroInteger, ParsePosNonzeroError> {
    // Обернём стандартные ошибки
    let x: i64 = s.parse().map_err(ParsePosNonzeroError::from_parseint)?;
    PositiveNonzeroInteger::new(x).map_err(ParsePosNonzeroError::from_creation)
}
```

### Проброс ошибок и оператор `?`
Достаточно часто имеет смысл не распаковывать `Result` тут же, а пробросить его из текущей функции выше и уже там обработать.

Можно сделать это классическим путём:
```rs
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}
```

А можно воспользоваться оператором `?`, который действует таким же образом, как первый `match` в листинге выше, то есть возвращает из выражения успешное значение либо возвращает из всей функции ошибку, упакованную в `Err(e)`:
```rs
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
```
Более того, можно после `?` обращаться к методам типа `T`, если вернулось `Ok(T)`:
```rs
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&mut username)?;

    Ok(username)
}
```

Для использования `?` в функции эта функция должна возвращать `Result<T, E>`, `Option<T>` либо другой тип, реализующий черту `FromResidual`
- Для возможности использовать `?` в `main` надо прописать такой возвращаемый тип: `fn main() -> Result<(), Box<dyn Error>>`. Теперь при возврате `Ok(())` будет код возврата `0`, при возврате любого типа ошибки будет иной код (подробнее об этом механизме будет позже)

Не всегда тип ошибки в `Result` перед `?` будет совпадать с типом ошибки, возвращаемым внешней функцией. В этом случае необходимо для типа внутренней ошибки определить черту `From` для конвертации во внешний тип

## Паниковать или нет?
*Вопрос достаточно комплексный, но во многом интуитивный, поэтому пробегусь по пунктам из этой подглавы лишь бегло*

Использовать `Result` имеет смысл в тех случаях, когда ошибка:
- Предусмотрена логикой (контрактом)
- Не несёт фатальных рисков для программы, пользователя и/или системы
- Мы хотим дать пользователю решать, что делать с ошибкой (актуально в первую очередь для библиотек)

В иных случаях рекомендуется паниковать, в частности:
- Если контракт метода вообще не предполагает возникновения ошибки такого типа. Куда разумнее будет **АгРеСсИвНо** сообщить об этом пользователю
- Если ошибка несёт большие риски

Стоит уделять внимание встроенным средствам отлова ошибок (банальный пример - указание более строгих типов - не `Option<u32>`, а просто `u32`, если мы и не предполагаем, что нам зачем-то может потребоваться `None`). Для своих типов также разумно задавать строгие ограничения и паниковать в случае их нарушения: например, если мы работаем только с числами от 1 до 100, можно написать структуру с полем числа, конструктор, паникующий при выходе за этот интервал, а поле числа сделать приватным, создав для него геттер:
```rs
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess { value }
    }

    pub fn value(&self) -> i32 {
        self.value
    }
}
```

# Generics
