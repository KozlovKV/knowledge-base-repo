- [Мотиватор](#мотиватор)
- [Полезные ссылки](#полезные-ссылки)
- [База](#база)
  - [Форматный вывод](#форматный-вывод)
  - [Переменные](#переменные)
    - [Shadowing (*замещение, перекрытие - хз, как это лучше назвать*)](#shadowing-замещение-перекрытие---хз-как-это-лучше-назвать)
  - [Типы данных](#типы-данных)
    - [Скалярные типы](#скалярные-типы)
    - [Составные типы](#составные-типы)
      - [Кортеж (tuple)](#кортеж-tuple)
      - [Массив (array)](#массив-array)
  - [Функции](#функции)
    - [Statements and expressions](#statements-and-expressions)
  - [Управление исполнением (`if`, `for` и пр.)](#управление-исполнением-if-for-и-пр)
    - [`if`](#if)
    - [Циклы](#циклы)
      - [`loop`](#loop)
      - [`while`](#while)
      - [`for`](#for)
- [Владение (ownership)](#владение-ownership)
  - [Владение и функции](#владение-и-функции)
  - [Ссылки (references) и заимствование (borrowing)](#ссылки-references-и-заимствование-borrowing)
  - [Slices](#slices)
- [Структуры данных](#структуры-данных)
  - [Методы](#методы)


# Мотиватор
```
 __________________________
< Hello fellow Rustaceans! >
 --------------------------
        \
         \
            _~^~^~_
        \) /  o o  \ (/
          '_   -   _'
          / '-----' \
```

# Полезные ссылки
- [Книжка от создателей](https://doc.rust-lang.org/book/#the-rust-programming-language)
- [Репозиторий с упражнениями](https://github.com/rust-lang/rustlings/)
  - *На самом деле прямо в упражнениях идут ссылки на эту же книжку, так что просто её читать смысла не вижу*
- [Общий список операторов](https://doc.rust-lang.org/book/appendix-02-operators.html)

# База
## Форматный вывод
Несколько похоже на сишный `printf`, но в разы удобнее и сдополнительными приколюхами:
```rs
// In general, the `{}` will be automatically replaced with any
// arguments. These will be stringified.
println!("{} days", 31);

// Positional arguments can be used. Specifying an integer inside `{}`
// determines which additional argument will be replaced. Arguments start
// at 0 immediately after the format string.
println!("{0}, this is {1}. {1}, this is {0}", "Alice", "Bob");

// As can named arguments.
println!("{subject} {verb} {object}",
        object="the lazy dog",
        subject="the quick brown fox",
        verb="jumps over");

// Different formatting can be invoked by specifying the format character
// after a `:`.
println!("Base 10:               {}",   69420); // 69420
println!("Base 2 (binary):       {:b}", 69420); // 10000111100101100
println!("Base 8 (octal):        {:o}", 69420); // 207454
println!("Base 16 (hexadecimal): {:x}", 69420); // 10f2c

// You can right-justify text with a specified width. This will
// output "    1". (Four white spaces and a "1", for a total width of 5.)
println!("{number:>5}", number=1);

// You can pad numbers with extra zeroes,
println!("{number:0>5}", number=1); // 00001
// and left-adjust by flipping the sign. This will output "10000".
println!("{number:0<5}", number=1); // 10000

// You can use named arguments in the format specifier by appending a `$`.
println!("{number:0>width$}", number=1, width=5);

// For Rust 1.58 and above, you can directly capture the argument from a
// surrounding variable. Just like the above, this will output
// "    1", 4 white spaces and a "1".
let number: f64 = 1.0;
let width: usize = 5;
println!("{number:>width$}");
```

Все варианты обращения к аргументам форматного вывода можно смешивать (разве что именованные должны быть после позиционных), хотя весьма нежелательно

Простой форматный вывод `{}` реализуется через `fmt::Display`, который по умолчанию у пользовательских типах не реализуется

Вызов `{:?}` вызывает `fmt::Debug` (пока что мне мало о чём говорит запись через двоеточие. И даже не очень понятно, что это за штуки с большой буквы - методы, функции или что-то подобно)

## Переменные
Объявляются ключевым словом `let var;`

Базово иммутабельны. Мы можем лишь единожды присвоить значение либо в момент объявления, либо позже (но обязательно до первого использования значения)

Для создания мутабельной переменной надо использовать `let mut mutable_var;`

Также мы можем объявить константы в любой области видимости (обычные переменные вне функции объявить нельзя), написав `const CONSTANT_VAR: type = value;` (*про типы речь пойдёт дальше*)
- Им нельзя присвоить результат функции, но можно нескольких операций (`60 * 60 * 24`, чтобы задать секунды в сутках и т.п.)

### Shadowing (*замещение, перекрытие - хз, как это лучше назвать*)
Особый механизм, позволяющий замещать значение **ИММУТАБЕЛЬНОЙ** переменной (**не константы**) в определённой области видимости. Заключается в том, что мы повторно объявляем переменную с тем же именем, у которой может быть другое значение и даже тип. Новое значение будет использоваться до конца области видимости, в которой она объявлена

```rs
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}
```
Вывод:
```
The value of x in the inner scope is: 12
The value of x is: 6
```

Кроме примера выше может быть удобно в случаях, когда мы хотим использовать значение единожды, а потом работать с его производной другого типа, но не хотим плодить много разных имён
```rs
let response = "4";
let response: u32 = response.parse().expect("Not a number!");
```

## Типы данных
Rust - язык со статической типизацией (*которая, впрочем, в некоторых отношениях достаточно податливая благодаря замещению*), однако нам часто нет нужды объявлять тип переменной, так как компилятор может предположить его по присваиваемым значениям.

Однако в некоторых случаях тип необходимо указать явно, так как компилятору будет недостаточно информации (*пример с парсингом выше. Без указания типа компилятор вообще не будет знать, что ему парсить*)

Типы данных делятся на скалярные и составные

### Скалярные типы
Скалярные типы предназначены для хранения одного значения:
- Целочисленные типы
  - В основном всё банально: имя типа составляется из буквы `i`/`u` и количества бит `8`/`16`/`32`/`64`/`128`
  - Особые типы: `isize`/`usize` - могут иметь разный размер в зависимости от архитектуры системы, исполняющей код. (в основном `32` либо `64` бита)
  - По умолчанию - `i32`
  - Отдельно объясняют особенности переполнения типов:
    - В дебаг-режиме при переполнении прога будет падать при помощи `panic!`
    - В релизе будет происходить классическое переполнение
    - Чтобы чётко быть уверенным в том, что всё работает корректно, рекомендуют использовать защищённые методы-обёртки для математических операций, которые обрезать результат в дебаге (`wrapping_*`), возвращать `None` при переполнении (`checked_*`), говорить о переполнении булевой переменной (`overflowing_*`), ограничивать переполнение границами типа (`saturating_*`)
- Типы с плавающей точкой: `f32` / `f64`. По умолчанию - `f64`
- Логический тип. `bool`: значения `true`/`false` - ничего интересного
- Символьный тип. `char`. Хранит юникод-символ => размер 4 байта

Большинство операций над этими типами не отличаются от операций в других языках. Особенно похоже на плюсы

### Составные типы
Составные типы позволяют хранить в себе множество значений. В Rust есть 2 примтивных составных типа (*цитата из книжки. Слово "примитивный" тут несколько загадочно звучит, скорее всего оно носит лишь декоративный смысл*)

#### Кортеж (tuple)
Набор данных **произвольных типов фиксированной длины**

Тип описывается `(type1, type2, ...)`. Также в некоторых случаях компилятор может сам определить тип

Получить доступ к элементам кортежа можно двумя способами:
- Обратиться по индексу через точку: `tuple.index`
- Провести деструкцию скобками: `(elem1, elem2, ...) = tuple` (**количество элементов в деструкции должно быть равно размеру кортежа**)

Пустой кортеж `()` называется `unit` и обозначает не только пустой кортеж, но и пустой возвращаемый тип

#### Массив (array)
Набор данных **одного типа фиксированной длины**

Массивы располагают данные на стэке (*а кортежи выходит на куче? Ладно, это должны рассказать позже*)

Декларация типа выглядит так: `[type; length]`

При присвоении значений массиву вместо перечисления элементов в квадратных скобках через запятую можно также использовать конструкцию с точкой с запятой `[value; length]`

Также поддерживает обращение по индексам (`array[index]`) и деструкцию (`[elem1, elem2, ...] = array`)

## Функции
Базовый вид:
```rs
fn function_name(arg1: type, arg2: type, ...) {
  // Function body
}
```
- Указывать типы аргументов **ОБЯЗАТЕЛЬНО**
- Можно определять функцию как до, так и после места её вызова. Главное, чтобы была в той же области видимости

Куда более интересными будут функции, возвращающие значения

### Statements and expressions
*Переведу на русский это как "заявления" и "выражения"*

**Ключевая для Rust концепция**

Statement - команды, производящие определённые действия, но не возвращающие значений
- Её значение не может быть присвоено переменной
- Заканчивается на точку с запятой
- *Пример:* `let x = 5;`

Expression - команды, возвращающие определённое значение
- В конце не должно быть точки с запятой
- **Фигурные скобки - тоже выражение** (*если, конечно, после них не поставить `;`*)
- Возвращаемое выражением значение определяется строкой без `;`, которая **должна быть в конце**
  - Если в конце нет выражения, то будет возвращаться `()`
  - Конкретно для функции мы можем возвращать значение раньше конца при помощи Statement `return <expression>;`

Звучит, пожалуй, несколько запутанно, поэтому вот ряд примеров:
```rs
// Функция, возвращающая 5
fn five() -> i32 {
  5 // Expression (да-да. Константы - тоже выражение)
}

fn five() -> i32 {
    5 // Ошибка - требуется точка с запятой
    print!("test");
} // Ошибка - возвращается () вместо i32

fn five() -> i32 {
    return 5; // Statement, говорящий, что нужно вернуть Expression {5}
    print!("test");
}

fn five(a: i32) -> i32 {
    if a % 2 == 0 {
        return 5;
    }
    print!("test");
} // Ошибка - возвращаемое значение может быть () вместо i32 (жесть тут умный компилятор)

// А теперь самые ядрёные примеры
fn sale_price(price: i32) -> i32 {
    if is_even(price) {
        price - 10
    } else {
        price - 3
    }
} // Корректно отработает, так как if - тоже выражение, возвращающий тот же тип, что и его условные выражение

fn sale_price(price: i32) -> i32 {
    if is_even(price) {
        price - 10
    } else {
        price - 3
    }
    println!("a");
} // Ошибка - возвращаемое значение () вместо i32

fn sale_price(price: i32) -> i32 {
    println!("a");
    if is_even(price) {
        price - 10
    } else {
        price - 3
    }
} // OK

fn sale_price(price: i32) -> i32 {
    return if is_even(price) {
        price - 10
    } else {
        price - 3
    };
    println!("a");
} // OK

fn sale_price(price: i32) -> i32 {
    if is_even(price) {
        return price - 10;
    } else {
        return price - 3;
    }
    println!("a");
} // OK

// Ясное дело, в последних двух примерах строка не выведется
```
*Выглядит страшновато, согласен, но спасает ситуацию то, что мы можем по классике использовать `return` - и не задумываться о таких тонкостях*

*Ну и да, если возвращается не `()`, то возвращаемый тип обязательно надо указывать*

## Управление исполнением (`if`, `for` и пр.)
### `if`
По большей части всё тривиально, интересный момент лишь в том, что условие (condition), определяющее ветку ифа - это тоже выражение (expression). Таким образом, обернув его в фигурные скобки, мы можем проводить там дополнительные операции:
```rs
fn bigger(a: i32, b: i32) -> i32 {
    // Если condition занимает одну строку, фигурные скобки можно опустить
    if a > b { 
        a
    } else {
        b
    }
}

// Эквивалентная функция
fn bigger(a: i32, b: i32) -> i32 {
    if {
        let diff = a - b;
        diff > 0
    } {
        a
    } else {
        b
    } // Скобки вокруг ветвей ифа опускать НЕЛЬЗЯ
}
```

Как уже отмечалось в примерах для функций, if expression имеет тот же возвращаемый тип, что и его ветки. Из этого следует, что мы можем использовать его в каком-нибудь statement:
```rs
// Ещё один эквивалент функциям выше
let maxNumber = if a > b {a} else {b}; // Приятнее классического тернарного оператора, не правда ли?
```

*Ну и `else if` тут тоже, само собой, есть*

### Циклы
#### `loop`
*Встроенный `while true`*

Также можно использовать `break` и `continue`, но с первым есть ряд фишек:
- `loop` - тоже expression. Его тип определяется expression, записанным после `break`:
```rs
let mut counter = 0;
let result = loop {
    counter += 1;
    if counter == 10 {
        break counter * 2;
    }
};
```
- Если прописать `'label: loop {}`, то вызов `break 'label;` прервёт именно этот цикл, даже если он не самый вложенный

#### `while`
Тут ничего особо интересного нет. Конструкция `break` обладает теми же доп. фишками
```rs
let mut counter = 0;

let result = 'test: while counter < 10 {
    if counter == 5 {
        break counter;
    }
    print!("{counter}");
    counter += 1;
};
```

#### `for`
В Rust используется конструкция `for-in` (похоже на Питон)

**ВСЕГДА ВОЗВРАЩАЕТ `()`** (нельзя использовать `break expression;` - только простой `break`)

Может итерироваться по любым коллекциям. `Range` задаётся конструкцией `start..end` (все числа в интервале `[start, end)`)

# Владение (ownership)
Уникальная фишка Rust, позволяющая безопасно работать с памятью, не используя сборщик мусора

*Для начала объясняется самая база про стэк и кучу, которая, спасибо Иртегову, мне ясна достаточно хорошо*

Основы владения:
- У каждого значения есть свой **владелец**
- Владелец может быть **только один в один момент времени**
- Когда владелец покидает область видимости, связанные с ним значения отбрасываются

В целом, эти правила описывают классическую ситуацию использования стэка. Ключевое отличие, что они также применяются и для участков памяти, расположенных на куче, что позволяет нам не тратить время на сборку мусора и, в то же время, не следить вручную за всей работой с памятью, однако может привести к неожиданным последствиям в некоторых случаях

Если данные по определённому указателю располагаются на куче и при этом для них реализована черта (trait - о них будет рассказано далее) `Drop`, то память по этому указателю будет очищена после выхода из области видимости указателя. Проблема возникнет в случае, когда у нас будет несколько типов данных с указателем на одну и ту же память:
```rs
{
    let mut s1 = String::from("some string");
    let mut s2 = s;
    // mut здесь дэ-факто не используется, но им я хотел подчеркнуть, что тип String, в отличие от строчного литерала str, может быть мутабельным в плане расширения строки и прочего
}
```
В этом примере в `s2` из `s1` скопируются значения полей типа `String`: указатель на область в памяти, где хранится строка, длина и макс. размер, то есть указатель у них один и тот же, из-за чего при выходе из области видимости `s1` и `s2` память под строку могла бы быть очищена дважды. 

Решается эта проблема тем, что `s1`, после копирования полей типа в `s2`, помечается невалидным - он не может далее использоваться и не будет проведена попытка очистки после выхода из области видимости

Таким образом, при приравнивании типов с чертой `Drop` происходит не поверхностное копирование (`shallow_copy`), а перемещение (`move`).

Чтобы всё же пользоваться обоими переменными, мы должны при присваивании вызывать метод `.clone()`, который скопирует содержимое памяти в новую область на куче (*`deep_copy`, хотя учитывая примитивность типа здесь этот термин не до конца применим*) (**более затратная операция, ясное дело**)

Поведение для примитивных типов отличается: их значения копируются быстро и не содержат сложной структуры, поэтому для строк
```rs
let x = 5;
let y = x;
```
в обеих будет значение 5 и обе продолжат быть валидными до конца области видимости (можно сказать, что тут неявно вызывается `.clone()`)

Кроме совсем примитивных типов, это относится к кортежам из примитивных типов и всем типам, реализующим черту `Copy` (*о том, как её реализовать, речь пойдёт сильно позже*)

## Владение и функции
При передаче аргументов в функции реализуется паттерн `move` для сложного типа и копирование для простого. То есть переданная переменна типа, реализующего черту `Drop`, после вызова функции перестанет быть валидной.

```rs
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it's okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
```

Владение возвращаемыми из функции данными, что логично, передаётся туда, где функция была вызвана

## Ссылки (references) и заимствование (borrowing)
Как следует из сказанного выше, после передача аргумента сложного типа в функцию, мы не сможем им пользоваться, так как владение на его значение было передано в другое место, где позже это значение было очищено.

Продолжить использование данных можно, передав аргумент обратно вместе с результатом, упаковав всё в кортеж, но это весьма неудобно, поэтому предлагается использовать ссылки.

**Ссылка** `&` позволяет нам назначить новую переменную со сложным типом без передачи владения:
```rs
let s = String::from("str");
let rs = &s;
println!(s); // OK
```
и
```rs
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    // Мы без проблем можем использовать s1 и после функции
    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

**Заимствованием** называется, собственно, доступ к объекту по ссылке (*мы временно берём владение на него, но потом возвращаем обратно*)

Использование ссылки не **делает объект мутабельным**. Этот код не скомпилируется:
```rs
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
```

Для аргумента функции нужно явно указать, что это мутабельная ссылка + исходный объект также должен быть мутабельным:
```rs
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
Напротив, мы можем создавать иммутабельные (обычные) ссылки на мутабельный объект

Если в области использования есть мутабельная ссылка, то она **должна быть единственной ссылкой на объект**
- **ВАЖНО:** речь именно об области использования. Область использования кончается там, где ссылка **была вызвана в последний раз**

Работает:
```rs
let mut s = String::from("aaa");
let rs = &mut s;
println!("{rs}");
{
    let rs2 = &mut s;

    println!("{rs2}");
}
```
Работает:
```rs
let mut s = String::from("aaa");
let rs = &mut s;
println!("{rs}");
let rs2 = &mut s;
println!("{rs2}");
```
НЕ РАБОТАЕТ:
```rs
let rs = &mut s;
let rs2 = &mut s;
println!("{rs2}");
println!("{rs}");
```
Иммутабельных ссылок на объект может быть много (**мутабельную вместе с ними, пусть даже одну, использовать нельзя**)

Правила могут казаться через строгими и порой неудобными, однако они позволяют ещё на этапе компиляции избежать многих возможностей создания data races (aka race condition)

Теоретически, ссылки могли бы быть висячими, если, например, мы бы возвращали её из функции на созданный в этой же функции объект (возвращение ссылки не передаёт владение, поэтому объект будет очищен в конце функции), однако компилятор следит и за этой ситуацией. Следующий код не запустится:
```rs
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String { // dangle returns a reference to a String

    let s = String::from("hello"); // s is a new String

    &s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
```

Очень-очень вероятно, что получение из функции ссылки - не то, чего мы хотим, поэтому стоит просто передавать владение:
```rs
fn no_dangle() -> String {
    let s = String::from("hello");
    s
}
```

Таким образом, нам гарантируется, что используемые референсы всегда валидны

## Slices
Среза в Rust являются особо структурой данных, а не просто коллекцией того же типа

Срез представляет собой структуру из указателя на данные и длины и создаётся путём обращения по указателю к переменной с изначальным типом и указания в квадратных скобках границ среза:
```rs
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]); // Ассёрт пройдёт корректно
```

Особенно часто используются срезы для строковых литералов (а на самом деле все строковые литералы представляют собой срез строки, хранящейся в бинарнике).

Преимуществом срезов является то, что они являются ссылками => гарантируется валидность данных, на которые указывает срез (*ну и все прочие моменты держим в голове вроде того, что мутабльный срез может быть лишь в одиночку*).

Этот код не вызовет ошибки, хотя после `.clear()` может работать некорректно:
```rs
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to ""

    // word still has the value 5 here, but there's no more string that
    // we could meaningfully use the value 5 with. word is now totally invalid!
}

fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
```

В свою очередь здесь компиляция упадёт на строке с очисткой, так как срез используется после неё (`.clear()` ввиду влияния на данные, внутри также пытается получить мутабельную ссылку):
```rs
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // error!

    println!("the first word is: {}", word);
}

fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

Дополнительно можно передавать в функцию `s: &str`. Это позволит функции одинаково работать как со строковыми литералами, так и со строками, так и с их срезами
```rs
fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or whole
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
```

*Возможно не до конца верная, но валидная, на мой взгляд, интерпретация:* таким образом, **срез** - ссылка на коллекцию или её часть

# Структуры данных
Объявление структур и их базовое использование очень банальны:
```rs
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}
```
Мутабельной может быть только вся структура целиком:
```rs
fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}
```

Если какие-то поля структуры у нас уже есть как отдельные переменные, мы можем использовать сокращённую запись:
```rs
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }

    // Вместо вот этого
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
```

Для копирования структуры можно использовать `..`:
```rs
fn main() {

    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };

    // Вместо:
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}
```

Для реализующих `Drop` типов **произойдёт передача владения**. По этой причине такие поля у `user1` перестанут быть доступны

Существуют также кортежи-структуры, которы позволяют к определённому имени привязать набор значений определённого типа, не давая им имена:
```rs
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
```
Несмотря на одинаковые поля, `Color` и `Point` - разные типы - одни нельзя заменить другими, однако и те, и другие поддерживают деструкцию и обращение по индексам

Можно создать структуру без полей, смысл которых будет раскрыт далее (*но если в общем, то они могут говорить о каком-то свойстве или чему-то сопоставляться*):
```rs
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
```

## Методы
*Обычные функции используются с объектами довольно тривиально и по всем описанным ранее правилам, так что сразу перейду к методам*

Создаются методы по следующему синтаксису:
```rs
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```

Первым аргументом у методов всегда должен быть параметр типа `Self` (вместо `self: Self` можно писать просто `self`), причём чаще всего это будет `&self` либо `&mut self`, так как правила владения тут те же => после вызова метода с аргументом просто `self`, вызывающий объект перестанет быть валидным (используется, когда мы что-то возвращаем и явно хотим закрыть доступ к исходному объекту)

Мы также можем задать статические методы (*зовутся здесь просто "ассоциированные со структурой методы без `self`"*):
```rs
impl Rectangle {
    fn square(size: u32) -> Self {
        Self {
            width: size,
            height: size,
        }
    }
}
```
Вызываться такой будет как `from()` для строк: `Rectangle::square(u32)`